---
title: 'Unit 5 Case Study: Exposure and Influence'
subtitle: "ECI 589 Social Network Analysis and Education"
author: "Dr. Shaun Kellogg"
date: "`r format(Sys.Date(),'%B %e, %Y')`"
output:
  html_document:
    toc: yes
    toc_depth: 4
    toc_float: yes
    code_folding: show
editor_options:
  markdown:
    wrap: 72
bibliography: lit/references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

## 1. PREPARE

Behind the social network visualizations explored in the chapter on
social network analysis, Chapter 12, there are also statistical models
that can be used to further understand relationships in a network.

One way to consider these models and methods is by considering selection
and influence, two processes at play in our relationships. These two
processes are commonly the focus of statistical analyses of networks.
Selection and influence do not interact independently: they affect each
other reciprocally (Xu, Frank, & Penuel, 2018).

Let's define these two processes:

-   **Selection**: the process of choosing relationships

-   **Influence**: the process of how our social relationships affect
    behavior

While these processes are complex, it is possible to study them using
data about people's relationships and behavior. Happily, the use of
these methods has expanded along with R. In fact, long-standing R
packages have become some of the best tools for studying social
networks. Additionally, while there are many nuances to studying
selection and influence, these are models that can be carried out with
relatively simple modeling techniques like linear regression.

#### ðŸ‘‰ Your Turn â¤µ

Let's load the {statnet} package that we'll be using in the Model
section of our case study for bullets 1-3 above, as well as the
following packages that will be using for our network analysis:

-   tidyverse
-   tidygraph
-   ggraph

```{r load-libraries}
# YOUR CODE HERE
library(tidyverse)
library(tidygraph)
library(ggraph)
```

------------------------------------------------------------------------

## 2. WRANGLE

For our data wrangling this week, we'll focus on working with network
data stored as an adjacency matrix. Our primary goals for this section
are learning how to:

a.  **Create Data Frames**. In this section, we use the {readxl} package
    from the tidyverse to read in a matrix and node attributes.

b.  **Dichotomize a Matrix**. As described in Chapter 9, we'll recode
    our edge values to 1s and 0s changing our valued matrix to a binary
    matrix.

c.  **Create Network Graph**. Finally, we'll convert our matrix to an
    edge-list and store both our edges and node attributes as a network
    igraph object in preparation for analysis.

### 2a. Create Data Frames

To examine a hypothetical case of network selection, first let's create
an **edgelist** that contains the nominator and nominee for a
relationship. For example, if Stefanie says that JosÃ© is her friend,
then Stefanie is the nominator and JosÃ© the nominee. Data frames like
this can also contain an optional variable indicating the weight, or
strength, of their relation.

#### Create Edgelist

Run the following code to create a data frame with three vairables that
contains dyads

```{r, create-edgelist}

data1 <- data.frame(nominator = c(2, 1, 3, 1, 2, 6, 3, 5, 6, 4, 3, 4), 
                    nominee = c(1, 2, 2, 3, 3, 3, 4, 4, 4, 5, 6, 6), 
                    relate = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) ) 


```

Next Data frames indicating the values of some behavior - an outcome -
at two different time points. In this example, we'll create example data
we can use to explore questions about influence.

Let's take a look at our three datasets:

-   data1: an **edgelist** that contains a nominator, nominee, and
    strength of the relation

-   data2: a dataset that contains the nominee and the values of some
    behavior at the first time point

-   data3: a dataset that contains a nominator and the value of some
    behavior at the second time point

Note that we will find each nominators' outcome at time 2 later on.
Here's how we can make these example datasets:

{r, eval = FALSE}

```{r}

data1 <- data.frame(nominator = c(2, 1, 3, 1, 2, 6, 3, 5, 6, 4, 3, 4), nominee = c(1, 2, 2, 3, 3, 3, 4, 4, 4, 5, 6, 6), relate = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) ) 

data2 <- data.frame(nominee = c(1, 2, 3, 4, 5, 6), yvar1 = c(2.4, 2.6, 1.1, -0.5, -3, -1)) 

data3 <- data.frame(nominator = c(1, 2, 3, 4, 5, 6), yvar2 = c(2, 2, 1, -0.5, -2, -0.5))
```

#### ðŸ‘‰ Your Turn â¤µ

### Joining the Data

Next, we'll join the data into one data frame. This step can be
time-consuming for large network datasets, but it's important for the
visualizations and analysis that follow. The more time you can invest
into preparing the data properly, the more confidence you'll have that
your resulting analysis is based on a deeper understanding of the data.

```{r}
data <- left_join(data1, data2, by = "nominee") |>
  mutate(nominee = as.character(nominee))



# calculate indegree in tempdata and merge with data 
tempdata <- data.frame(table(data$nominee)) 

tempdata <- tempdata %>% rename( 
  # rename the column "Var1" to "nominee" 
  "nominee" = "Var1", 
  # rename the column "Freq" to "indegree" 
  "indegree" = "Freq" ) %>% 
  # makes nominee a character data type, instead of a factor, which can cause problems 
  mutate(nominee = as.character(nominee))



data <- left_join(data, tempdata, by = "nominee")

```

### 2c. Create Network with Attributes

Recall that edge-lists contain a row for each dyad consisting of at
minimum two columns with the name of each actor, and which conveniently
can also contain other information or attributes about the relationship
such as edge weight, timestamps, or other contextual information as
demonstrated in Unit 1.

Edge-lists also have the advantage of being easier to work with when
using network packages in R.

#### Get Edges

The {igraph} package introduced in Unit 1 has a convenient
`get.data.frame()` function for extracting an edge list from a matrix,
but first we need to convert our matrix to an igraph network object.

```{r extract-edges}
adjacency_matrix <- graph.adjacency(leader_matrix,
                                    diag = FALSE)

class(adjacency_matrix)

adjacency_matrix
```

Note that we included the `diag = FALSE` argument which converts all
values along the diagonal to 0s, thereby removing self-loops. I believe
they may have been included when calculating the network descriptives
included in Table 9.1, and our own descriptives may not match exactly,
but we'll need to remove these from our network for the ERGM analysis so
this will save us a step.

Now we can use the `get.data.frame()` function to covert our matrix to a
standard edge-list:

```{r convert-edgelist}
leader_edges <- get.data.frame(adjacency_matrix) |>
  mutate(from = as.character(from)) |>
  mutate(to = as.character(to))


leader_edges
```

#### ðŸ‘‰ Your Turn â¤µ

Recall from Unit 2 that we introduced the {tidygraph} package for
preparing and summarizing our Twitter network. Tidygraph includes the
full functionality ofÂ `igraph`Â in a tidy API giving you access to almost
all of theÂ `dplyr`Â verbs plus a few more, developed for use with
relational data.

Similar to Unit 2, use the `tbl_graph()` function to convert our
`leader_edges` and `leader_nodes` data frames into a network graph
object, by including the following arguments and supplying the
appropriate code:

-   `edges =` expects a data frame, in our case `leader_edges`,
    containing information about the edges in the graph. The nodes of
    each edge must either be in a `to` and `from` column, or in the two
    first columns like the data frame we provided.

-   `nodes =` expects a data frame, in our case `leader_nodes`,
    containing information about the nodes in the graph. If `to` and/or
    `from` are characters or names, like in our data frames, then they
    will be matched to the column named according to `node_key` in
    nodes, if it exists, or matched to the first column in the node
    list.

-   `directed =` specifies whether the constructed graph be directed.

```{r create-network}
# YOUR CODE HERE
leader_graph <- tbl_graph(edges = leader_edges,
                          nodes = leader_nodes,
                          directed = TRUE)


leader_graph
```

Congrats! You made it to the end of data wrangling section and are ready
to start analysis!

------------------------------------------------------------------------

## 3. EXPLORE

In Section 3, we use the {tidygraph} package for retrieving network
descriptives and the {ggraph} package to create a network visualization
to help illustrate these metrics. Specifically, in this section we will:

a.  **Examine Basic Descriptives**. We focus primarily on actors and
    edges in this walkthrough, including whether or not ties were
    reciprocated and node degree, an important and fairly intuitive
    measure of centrality.

b.  **Make a Sociogram**. Finally, we wrap up the explore phases by
    learning to plot a network and tweak key elements like the size,
    shape, and position of nodes and edges to better at communicating
    key findings.

### 3a. Examine Descriptives

As noted in SNA and Education [@carolan2014], many analyses of social
networks are primarily descriptive and aim to either represent the
network's underlying social structure through data-reduction techniques
or to characterize network properties through network measures.

In the analyses described in Chapter 9, descriptives were limited to the
mean and standard deviation for: in-degree, out-degree, trust and
efficacy measures. The proportion of male leaders was also reported. For
section 3a, let's see if we can reproduce these descriptives.

#### Calculate Node Degree

Recall that **degree** is the number of ties to and from an ego, or in
the case of a "simple graph" like ours, degree is simply the number of
people to whom someone is connected. In a directed network,
**in-degree** is the number of connections or ties received, whereas
**out-degree** is the number of connections or ties sent.

The `activate()` function from the {tidygraph} package allows us to
treat the nodes in our network object as if they were a standard data
frame to which we can then apply tidyverse functions such as `select()`,
`filter()`, and `mutate()`.

We can use the `mutate()` functions to create new variables for nodes
such as measures of degree, in-degree, and out-degree using the
`centrality_degree()` function in the {tidygraph} package.

Run the following code to add in- and out-degree measures to each of our
nodes and examine the output:

```{r add-indegree}
leader_measures <- leader_graph |>
  activate(nodes) |>
  mutate(in_degree = centrality_degree(mode = "in")) |>
  mutate(out_degree = centrality_degree(mode = "out"))

leader_measures
```

#### ðŸ‘‰ Your Turn â¤µ

We now see that, in addition to the previously included attributes
`trust` and `efficacy`, in-degree and out-degree measures have been
added to the nodes in our network. But what if we also want to know to
total number of "alters" each "ego" is connected to, i.e. the total
number of individuals each school leader are connected to?

Modify the code below to calculate `degree` for each school leader in
our network. **Hint:** `centrality_degree` is a wrapper for
`igraph::degree()` and the `mode =` argument can be found in the
corresponding help documentation.

```{r add-degree}
leader_measures <- leader_graph |>
  activate(nodes) |>
  mutate(degree = centrality_degree(mode = "all")) |>
  mutate(in_degree = centrality_degree(mode = "in")) |>
  mutate(out_degree = centrality_degree(mode = "out"))

leader_measures
```

#### Summarize Node Measures

We can also use the `activate()` function combined with the
`as_tibble()` function introduced in our previous unit to extract our
new measures to a separate data frame we'll call `node_measures` so we
can inspect our nodes individually and later use to calculate some
summary stats:

```{r create-tibble}
node_measures <- leader_measures |> 
  activate(nodes) |>
  as_tibble()

node_measures
```

Now let's view some basic summary statistics for each of the variables
using the handy `summary()` function included in the R {base} package
and the `skim()` functions from the {skimr} package.

```{r summarize-measures}
summary(node_measures)

skim(node_measures)
```

It looks like our summary stats for Year 3 confidential exchanges
network and attribute data are pretty close to those reported in Table
9.1 copied from @carolan2014. For example, our mean total efficacy and
trust scores were 6.65 and 4.78 respectively, compared to 6.64 and 4.77
as reported in Chapter 9.

![](img/table-9-1.jpg){width="80%"}

The average in/out-degree for our school leaders data is 3.26, however,
which is a little lower than that reported by Carolyn. Again, this is
likely a function of our removal of self-loops. To test this theory, we
could simply change the `diag = FALSE` argument added to the
`graph.adjacency()` function above to `TRUE` to include self-loops and
then try rerunning all the code above.

#### School/District-Level Stats

Since we are now working with a standard data frame, we can also apply
[{dyplr}](https://dplyr.tidyverse.org/index.html) functions like
[`group_by()`](https://dplyr.tidyverse.org/reference/group_by.html) and
[`summarise()`](https://dplyr.tidyverse.org/reference/summarise.html) to
calculate basic summary stats such as counts, mean, and standard
deviation as follows:

```{r group-stats}
node_measures |>
  group_by(district_site) |>
  summarise(n = n(),
            mean = mean(in_degree), 
            sd = sd(in_degree)
            )
```

We see that our measures are pretty close, but not an exact match.
Again, this is likely due to the self-loops we excluded. For example,
our average in-degree for district-level (coded "1") and school-level
(coded "0") leaders is 4.66 and 2.36 respectively, but reported as 4.72
and 2.64 by @carolan2014.

#### ðŸ‘‰ Your Turn â¤µ

Use the code chunk below and additional chunks if needed to try and
replicate the school and district level findings for out-degree, trust
and efficacy measures.

```{r replicate-findings}
node_measures |>
  group_by(district_site) |>
  summarise(n = n(),
            mean = mean(out_degree), 
            sd = sd(out_degree)
            )

node_measures |>
  group_by(district_site) |>
  summarise(n = n(),
            mean = mean(trust), 
            sd = sd(trust)
            )

node_measures |>
  group_by(district_site) |>
  summarise(n = n(),
            mean = mean(efficacy), 
            sd = sd(efficacy)
            )
```

How close your result to those reported by Carolyn Table 9.1?

-   YOUR RESPONSE HERE

### 3b. Visualize Network Properties

In Chapter 9, @carolan2014 depicts a directed and dichotomous sociogram
of the **collaboration** network for year 3 is shown in .

![](img/figure-9-1.jpg){width="80%"}

#### ðŸ‘‰ Your Turn â¤µ

Try creating a **Year 3 Confidential Exchange Network** by modifying the
code below and tweaking the included function/arguments or adding new
ones for
[layouts](https://ggraph.data-imaginist.com/articles/Layouts.html),
[nodes](https://ggraph.data-imaginist.com/articles/Nodes.html), and
[edges](https://ggraph.data-imaginist.com/articles/Edges.html) to make
our plot either more "aesthetically pleasing" or more purposeful in what
it's trying to communicate.

```{r improve-sociogram}
#YOUR CODE HERE
leader_measures |>
ggraph(layout = "fr") + 
  geom_node_point() +
  geom_edge_link() + 
  theme_graph()
```

After you are satisfied with your sociogram, answer the following
questions?

1.  How is the Year 3 confidential exchange network similar to the
    collaboration network? How is it different?

    -   YOUR RESPONSE HERE

Congrats! You made it to the end of the Explore section and are ready to
learn a little ab out modeling network selection processes using ERGMs!
Before proceeding further, knit your document and check to see if you
encounter any errors.

------------------------------------------------------------------------

## 4. MODEL

Recall from @carolan2014 that network models and the questions they are
designed to address are categorized into three different analytical
emphases:

1.  Relationship-level models that focus on the ties between actors in
    complete networks;

2.  Models that predict individual actors' attributes; and,

3.  Actor-level models that emphasize the differences within and among
    groups of actors within a complete network.

**Exponential Random Graph Models** fall into category 1 and are
relationship-level models that focus on how formation of dyadic ties
within a complete relational network can be explained by both structural
and attribute variables. ERGMs provide a means to compare whether a
network's observed structural properties occur more frequently than you
could expect from chance alone. More specifically, ERGMS provide a way
to determine whether observed network properties like reciprocity and
assortativity occur by chance as a result of other network properties.

While the technical aspects of estimating ERGMs are complex, their
interpretation is pretty straightforward. In this section we are
interested exploring how these models can be used to make inferences
about the social processes at work in the School Leaders data. For
example, in this section we will explore the following questions posed
in Chapter 9:

1.  **Reciprocity.** If one school leader turns to another to discuss
    something confidential, is the latter likely to reciprocate?

2.  **Transitivity.** Are school leaders more likely to confide in
    someone if they both confide in the same school leader?

3.  **Attribute Effect.** Do a leader's gender and efficacy score,
    predict a confidential exchange between two leaders?

### 4a. Loading Network Data

Calculating an Exposure Term

Next we'll create an exposure term. This is the key step that makes this
linear regression model special. The idea is that the exposure term
"captures" how your interactions with someone over the first and second
time points impact an outcome. The model describes a change in this
outcome because it takes the first and second time points into
account.{r, eval = FALSE}

```{r}
# Calculating exposure 
data <- data %>% mutate(exposure = relate * yvar1) 
# Calculating mean exposure 

mean_exposure <- data %>% group_by(nominator) %>% summarize(exposure_mean = mean(exposure))
```

The data frame mean_exposure contains the mean of the outcome (in this
case, yvar1) for all of the individuals the nominator had a relation
with.Let's process the data more so we can add the variables
exposure_mean, yvar1, and yvar2.

{r, eval = FALSE}

```{r}
data2 <- data2 %>% 
  # rename nominee as nominator to merge these 
  rename("nominator" = "nominee") 

final_data <- left_join(mean_exposure, data2, by = "nominator") 

final_data <- 
  # data3 already has nominator, so no need to change 
  left_join(final_data, data3, by = "nominator") 
```

Regression (Linear Model)

Calculating the exposure term is the most distinctive and important step
in carrying out influence models. Now, we can use a linear model to find
out how much relations - as captured by the influence term - affect some
outcome. While this code is not run here, you could run the code in this
appendix to see the results (and how changes in how the exposure term is
calculated, such as by finding the sum, instead of the mean, of each
individual's exposures, impact the results.){r, eval = FALSE}

```{r}

model1 <- lm(yvar2 ~ yvar1 + exposure_mean, data = final_data) 
summary(model1)
```

So, the influence model is used to study a key process for social
network analysis. It's useful because it's one way you can quantify the
network effect. This is a metric that's not always considered in
education, but we hope to see more of it (Frank, 2009). It also helps
that it can be done with a relatively straight forward regression model.

An Example of SelectionLet's look at selection models next. Information
from selection models can be useful to a wide audience--administrators,
teachers, and students--because it describes how members of a network
choose who to interact with. Here, we briefly describe a few possible
approaches for using a selection model to learn more about a social
network.In the last section we used a linear regression model. In this
example we'll use a logistic regression model. Logistic regressions
model outcomes that are either a 0 or a 1. Thus, the most
straightforward way to use a selection model is to use a logistic
regression where all of the relations (note the relate variable in data1
above) are indicated with a 1.But, here is the important and challenging
step: all of the possible relations between members of a network are
indicated with a 0 in an edgelist. Recall that an edgelist is the
preferred data structure for carrying out this analysis. This step
requires that we prepare the data by lengthening and widening it.Once
all of the relations are given a value of either a 1 or a 0, then a
logistic regression can be used. Imagine that we are interested in
whether individuals from the same group are more or less likely to
interact than those from different groups. To answer this question, one
could create a new variable called same and then fit the model using
code (which is not run, but is included as an example of the code for
this kind of selection model) like this:{r, eval = FALSE} m_selection
\<- glm(relate \~ 1 + same, data = edgelist1)While this is a
straightforward way to carry out a selection model, there are some
limitations. First, it doesn't account for the amount of nominations an
individual sends. Not considering this may mean other effects, like the
one associated with being from the same group, are not accurate. Some R
packages aim to address this by considering other variables like
relationship weights. Here are some examples:The {amen} [\@R-amen]
package can be used for data that is not only 1s and 0s - like a
logistic regression - but also data that is normally distributedThe
Exponential Random Graph Model, or {ergm} R package, makes it easy to
use these kinds of selection models. {ergm} [\@R-ergm] is itself a part
of a powerful and often-used collection of packages for social network
analysis, {statnet} [\@R-statnet]These packages are examples of the
richness R packages can bring to using social network analysis models
and methods. As developments in social network analysis methods
continue, more cutting-edge techniques and R packages will be available.

#### ðŸ‘‰ Your Turn â¤µ

Use the code chunk below to check the model fit and diagnostics for the
model the you created in [4b. Estimate the ERGM Model]:

```{r check-ergm-4}
#YOUR CODE HERE
ergm_4_gof <- gof(ergm_4)

plot(ergm_4_gof)

mcmc.diagnostics(ergm_4)
```

------------------------------------------------------------------------

## 5. COMMUNICATE

For your final Your Turn, your goal is to distill our analysis from
above into a simple "data product" designed to illustrate key findings
about changes in the collaboration network over time. For the purposes
of this task, imagine that your audience consists of the developers and
facilitators of the DLT MOOC-Eds who have limited background in SNA and
adapt the following steps accordingly:

1.  **Select.** Select your ERGM analysis from above, or a new analysis
    if so motivated, that you think would be interesting or relevant for
    the target audience and that helps answer our research questions.

2.  **Polish.** Create and polish a data visualization and/or data table
    to communicate your selected findings.

3.  **Narrate.** Write a brief narrative (2-3 paragraphs) to accompany
    your visualization and/or table that includes the following:

    -   The question or questions guiding the analysis;

    -   The conclusions you've reached based on our findings;

    -   How your audience might use this information;

    -   How you might revisit or improve upon this analysis in the
        future.

### ðŸ‘‰ Your Turn â¤µ

Use the code chunk below create a polished table and/or visualization(s)
and write a brief narrative in the space that follows.

### Data Visualization or Table

```{r create_data_product}
# YOUR CODE HERE


```

### Narrative

NARRATIVE GOES HERE...

### ðŸ§¶ Knit & Check âœ…

Congratulations - you've completed the Unit 3 case study! To share your
work, click the drop down arrow next to the ball of yarn that says
"Knit" at the top of this markdown file, then select "Knit top HTML".
Assuming your code contains no errors, this will create a web page in
your Files pane that serves as a record of your work.

Once your file has been knitted, you can publish this file online using
RPubs, or share the HTML file through another means.

### References
